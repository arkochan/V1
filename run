#!/usr/bin/env python3
"""
Development environment manager for Go backend and Next.js frontend.
Provides a terminal UI for managing services with keyboard shortcuts.
No external dependencies - uses only Python standard library.
"""

import os
import sys
import re
import subprocess
import signal
import time
import threading
import select
import termios
import tty
import datetime
from typing import Optional, Dict, List
import argparse


# ANSI Color Codes
RESET = "\033[0m"
BOLD = "\033[1m"
DIM = "\033[2m"
GO_COLOR = "\033[38;5;81m"
NEXT_COLOR = "\033[38;5;120m"
SYSTEM_COLOR = "\033[38;5;214m"
ERROR_COLOR = "\033[38;5;196m"
TIME_COLOR = "\033[38;5;244m"

# ============= Environment Parser =============
VAR_PATTERN = re.compile(r"(?<!\\)\$\{([^}]+)\}")  # matches ${VAR}, not \${VAR}


def expand_vars(value, env):
    """Expand ${VAR} using values from env."""

    def repl(match):
        var = match.group(1)
        return env.get(var, "")

    value = VAR_PATTERN.sub(repl, value)
    return value.replace(r"\${", "${")  # unescape \${VAR}


def parse_env_line(line):
    """Parse a single .env line into (key, value) or None."""
    line = line.strip()

    # Skip empty or full-line comments
    if not line or line.startswith("#"):
        return None

    # Remove 'export '
    if line.startswith("export "):
        line = line[len("export ") :].lstrip()

    # Split key=value
    if "=" not in line:
        return None

    key, value = line.split("=", 1)

    key = key.strip()
    value = value.strip()

    # Remove inline comments (only if outside quotes)
    if value and not (value.startswith('"') or value.startswith("'")):
        if " #" in value:
            value = value.split(" #", 1)[0].rstrip()
        elif "#" in value:
            value = value.split("#", 1)[0].rstrip()

    # Remove surrounding quotes
    if (value.startswith('"') and value.endswith('"')) or (
        value.startswith("'") and value.endswith("'")
    ):
        value = value[1:-1]

    return key, value


def load_dotenv(path=".env"):
    """
    Parse .env file with variable expansion.
    Returns dict of variables defined in the file.
    """
    env = {}
    base = os.environ.copy()

    if not os.path.exists(path):
        return env

    with open(path) as f:
        for raw in f:
            parsed = parse_env_line(raw)
            if not parsed:
                continue

            key, value = parsed

            # Merge known environment for expansion
            expanded = expand_vars(value, {**base, **env})
            env[key] = expanded

    return env


class ServiceManager:
    """Manages a single service process with lifecycle operations."""

    def __init__(
        self,
        name: str,
        cmd: List[str],
        cwd: str,
        color: str,
        env: Optional[Dict[str, str]] = None,
    ):
        self.name = name
        self.cmd = cmd
        self.cwd = cwd
        self.color = color
        self.env = env or {}
        self.pid: Optional[int] = None
        self.status = "stopped"
        self.process: Optional[subprocess.Popen] = None
        self.lock = threading.Lock()

    def start(self) -> bool:
        """Start the service process."""
        with self.lock:
            if self.process and self.process.poll() is None:
                return True

            self.status = "starting"
            self._print_status(f"Starting {self.name}...")

            # Merge system env with parsed .env vars
            env = os.environ.copy()
            env.update(self.env)

            try:
                # Create new process session for clean process group management
                self.process = subprocess.Popen(
                    self.cmd,
                    cwd=self.cwd,
                    env=env,
                    stdout=subprocess.PIPE,
                    stderr=subprocess.STDOUT,
                    text=True,
                    start_new_session=True,  # Key for clean process killing
                )
                self.pid = self.process.pid
                time.sleep(2)

                if self.process.poll() is None:
                    self.status = "running"
                    self._print_status(f"{self.name} started (PID: {self.pid})")

                    # Start log forwarding thread
                    thread = threading.Thread(target=self._log_forwarder, daemon=True)
                    thread.start()
                    return True
                else:
                    self.status = "stopped"
                    self._print_error(
                        f"{self.name} failed to start (exit code: {self.process.returncode})"
                    )
                    return False

            except FileNotFoundError as e:
                self.status = "stopped"
                self._print_error(f"Command not found: {self.cmd[0]} - {e}")
                return False
            except Exception as e:
                self.status = "stopped"
                self._print_error(f"Error starting {self.name}: {e}")
                return False

    def stop(self) -> None:
        """Stop service and its entire process tree."""
        with self.lock:
            if not self.process or self.process.poll() is not None:
                self.pid = None
                self.process = None
                self.status = "stopped"
                return

            self._print_status(f"Stopping {self.name} (PID: {self.pid})...")

            try:
                # Kill entire process group using negative PID
                if self.pid is None:
                    self._print_error(f"No PID found for {self.name}, cannot stop")
                    self.process = None
                    self.pid = None
                    self.status = "stopped"
                    return
                pgid = os.getpgid(self.pid)
                os.killpg(pgid, signal.SIGTERM)

                # Wait for graceful shutdown (5s max)
                for _ in range(50):
                    if self.process.poll() is not None:
                        break
                    time.sleep(0.1)
                else:
                    # Force kill if still alive
                    self._print_status(f"Force killing {self.name}...")
                    os.killpg(pgid, signal.SIGKILL)
                    time.sleep(0.5)

            except ProcessLookupError:
                pass
            except Exception as e:
                self._print_error(f"Error stopping {self.name}: {e}")

            self.process = None
            self.pid = None
            self.status = "stopped"

    def restart(self) -> bool:
        """Restart the service."""
        self._print_status(f"Restarting {self.name}...")
        self.status = "restarting"
        self.stop()
        time.sleep(0.5)
        return self.start()

    def _log_forwarder(self) -> None:
        """Forward and format logs from service stdout."""
        if not self.process or not self.process.stdout:
            return

        for line in iter(self.process.stdout.readline, ""):
            if line and not self.process.poll():
                timestamp = datetime.datetime.now().strftime("%H:%M:%S")
                gutter = "[go]  " if self.name == "Go" else "[next]"
                print(
                    f"{TIME_COLOR}{timestamp}{RESET} {self.color}{gutter}{RESET} {line.rstrip()}"
                )
                sys.stdout.flush()

    def _print_status(self, msg: str) -> None:
        """Print system status message."""
        print(f"{SYSTEM_COLOR}[system]{RESET} {BOLD}{msg}{RESET}")
        sys.stdout.flush()

    def _print_error(self, msg: str) -> None:
        """Print error message."""
        print(f"{ERROR_COLOR}[system]{RESET} {msg}")
        sys.stdout.flush()


class TUI:
    """Terminal User Interface for service management."""

    def __init__(self, go_enabled=True, next_enabled=True):
        # Parse .env file with variable expansion
        self.parsed_env = load_dotenv(".env")

        if self.parsed_env:
            print(
                f"{SYSTEM_COLOR}[system]{RESET} {DIM}Loaded {len(self.parsed_env)} variables from .env{RESET}"
            )
        else:
            print(
                f"{SYSTEM_COLOR}[system]{RESET} {DIM}No .env file found or empty{RESET}"
            )

        # Create services based on arguments
        self.services = {}
        self.go_enabled = go_enabled
        self.next_enabled = next_enabled

        if go_enabled:
            self.services["go"] = ServiceManager(
                name="Go",
                cmd=["make", "dev"],
                cwd="apps/go-app",
                color=GO_COLOR,
                env=self.parsed_env,  # All parsed env vars available to Go
            )

        if next_enabled:
            self.services["next"] = ServiceManager(
                name="Next.js",
                cmd=["bun", "run", "dev"],
                cwd="apps/next-app",
                color=NEXT_COLOR,
                env=self.parsed_env,  # All parsed env vars available to Next.js
            )

        self.last_key = ""
        self.last_key_time = 0.0
        self.shutting_down = False

    def setup_terminal(self) -> None:
        """Configure terminal for immediate input."""
        self.fd = sys.stdin.fileno()
        self.old_settings = termios.tcgetattr(self.fd)
        tty.setcbreak(self.fd)
        sys.stdout.write("\033[?25l")  # Hide cursor
        sys.stdout.flush()

    def restore_terminal(self) -> None:
        """Restore terminal to original state."""
        sys.stdout.write("\033[?25h")  # Show cursor
        sys.stdout.flush()
        termios.tcsetattr(self.fd, termios.TCSADRAIN, self.old_settings)

    def print_header(self) -> None:
        """Display current service status header."""
        print(
            f"{BOLD}‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ{RESET}"
        )

        # Print Go status if enabled
        if self.go_enabled:
            print(f"{BOLD}  Go Backend: {RESET}", end="")
            symbols = {
                "running": f"{GO_COLOR}‚óè{RESET} running  ",
                "starting": f"{SYSTEM_COLOR}‚óê{RESET} starting ",
                "stopped": f"{ERROR_COLOR}‚óã{RESET} stopped  ",
                "restarting": f"{SYSTEM_COLOR}‚Üª{RESET} restarting ",
            }
            go_status = self.services["go"].status
            print(symbols.get(go_status, "unknown "), end="")

        # Print Next status if enabled
        if self.next_enabled:
            print(f"{BOLD}Next.js: {RESET}", end="")
            symbols = {
                "running": f"{NEXT_COLOR}‚óè{RESET} running",
                "starting": f"{SYSTEM_COLOR}‚óê{RESET} starting",
                "stopped": f"{ERROR_COLOR}‚óã{RESET} stopped",
                "restarting": f"{SYSTEM_COLOR}‚Üª{RESET} restarting",
            }
            next_status = self.services["next"].status
            print(symbols.get(next_status, "unknown"))

        # Print controls based on which services are enabled
        controls = []
        if self.go_enabled and self.next_enabled:
            controls.append("g‚Üír: restart Go")
            controls.append("n‚Üír: restart Next")
            controls.append("r: restart all")
        elif self.go_enabled:
            controls.append("g‚Üír: restart Go")
        elif self.next_enabled:
            controls.append("n‚Üír: restart Next")

        controls.append("Ctrl+C: quit")
        print(f"{DIM}  {'  |  '.join(controls)}{RESET}")
        print(
            f"{BOLD}‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ{RESET}"
        )
        sys.stdout.flush()

    def handle_input(self) -> None:
        """Process keyboard commands."""
        if select.select([sys.stdin], [], [], 0.1)[0]:
            char = sys.stdin.read(1)
            current_time = time.time()

            # Reset chord on timeout
            if self.last_key and (current_time - self.last_key_time > 1.0):
                self.last_key = ""

            chord = self.last_key + char

            if chord == "gr" and self.go_enabled:
                self.last_key = ""
                print("\033[2J\033[H")  # Clear screen
                self.print_header()
                self.services["go"].restart()
            elif chord == "nr" and self.next_enabled:
                self.last_key = ""
                print("\033[2J\033[H")
                self.print_header()
                self.services["next"].restart()
            elif chord == "r" and not self.last_key:
                self.last_key = ""
                print("\033[2J\033[H")
                self.print_header()
                self.restart_all()
            elif char in ("g", "n"):
                # Only accept if the corresponding service is enabled
                if (char == "g" and self.go_enabled) or (
                    char == "n" and self.next_enabled
                ):
                    self.last_key = char
                    self.last_key_time = current_time
            else:
                self.last_key = ""

    def restart_all(self) -> None:
        """Restart both services."""
        print(f"{SYSTEM_COLOR}[system]{RESET} {BOLD}Restarting all services...{RESET}")
        for service in self.services.values():
            service.restart()
        print(f"{SYSTEM_COLOR}[system]{RESET} {DIM}All services restarted{RESET}")
        sys.stdout.flush()

    def cleanup(self) -> None:
        """Graceful shutdown of services and terminal restoration."""
        if self.shutting_down:
            return
        self.shutting_down = True

        print()
        print(f"{SYSTEM_COLOR}[system]{RESET} {BOLD}Shutting down...{RESET}")

        for service in self.services.values():
            service.stop()

        self.restore_terminal()
        time.sleep(0.1)  # Ensure terminal is fully restored

        print(
            f"{SYSTEM_COLOR}[system]{RESET} {DIM}All services stopped. Goodbye!{RESET}"
        )
        sys.stdout.flush()

    def run(self) -> None:
        """Main TUI execution loop."""

        def signal_handler(sig, frame):
            self.cleanup()
            sys.exit(0)

        signal.signal(signal.SIGINT, signal_handler)
        signal.signal(signal.SIGTERM, signal_handler)

        self.setup_terminal()

        print("\033[2J\033[H")  # Clear screen
        self.print_header()

        print(f"{SYSTEM_COLOR}[system]{RESET} {BOLD}Starting services...{RESET}")
        for service in self.services.values():
            service.start()

        try:
            while not self.shutting_down:
                self.handle_input()

                # Health monitoring
                for name, service in self.services.items():
                    if service.status == "running" and service.process:
                        if service.process.poll() is not None:
                            service.status = "stopped"
                            print(
                                f"{ERROR_COLOR}[system]{RESET} {service.name} stopped unexpectedly"
                            )

                time.sleep(0.1)
        finally:
            # Ensure cleanup runs even on unexpected errors
            self.cleanup()


# Docker command functions
def docker_up_dev():
    """Start Docker development environment."""
    print("\nüê≥ Starting Docker dev environment...")
    subprocess.run(["docker", "compose", "-f", "docker-compose.dev.yml", "up", "-d"])


def docker_down_dev():
    """Stop Docker development environment."""
    print("\nüê≥ Stopping Docker dev environment...")
    subprocess.run(["docker", "compose", "-f", "docker-compose.dev.yml", "down"])


def docker_up_prod():
    """Start Docker production environment."""
    print("\nüöÄ Starting Docker prod environment...")
    subprocess.run(["docker", "compose", "-f", "docker-compose.prod.yml", "up", "-d"])


def docker_down_prod():
    """Stop Docker production environment."""
    print("\nüõë Stopping Docker prod environment...")
    subprocess.run(
        [
            "docker",
            "compose",
            "-f",
            "docker-compose.prod.yml",
            "down",
            "--remove-orphans",
        ]
    )


def run_migrate(args):
    """Run migration command with parsed environment variables."""
    parsed_env = load_dotenv(".env")

    if args.subcommand == "create":
        # Special handling for migrate create command
        # Use fixed path as specified: /home/arkochan/Repositories/V1/db/pg/migrations
        migrations_dir = "/home/arkochan/Repositories/V1/db/pg/migrations"

        cwd = os.path.dirname(os.path.abspath(__file__))
        # Build the migrate create command with specific parameters
        absolute_dir = os.path.join(cwd, migrations_dir)
        cmd = [
            "migrate",
            "create",
            "-ext",
            "sql",
            "-dir",
            absolute_dir,
            "-seq",
            args.file_name,
        ]

        print(
            f"{SYSTEM_COLOR}[system]{RESET} {BOLD}Running migration create: {' '.join(cmd)}{RESET}"
        )

        try:
            result = subprocess.run(cmd, check=True)
            print(f"{SYSTEM_COLOR}[system]{RESET} Migration created successfully")
        except subprocess.CalledProcessError as e:
            print(
                f"{ERROR_COLOR}[error]{RESET} Migration create failed with exit code {e.returncode}"
            )
            sys.exit(e.returncode)
        except FileNotFoundError:
            print(
                f"{ERROR_COLOR}[error]{RESET} migrate command not found. Make sure migrate is installed."
            )
            sys.exit(1)
    else:
        # Get migration source and database URL from environment for other commands
        migrations_source = parsed_env.get("MIGRATIONS")
        database_url = parsed_env.get("DATABASE_URL")

        if not migrations_source:
            print(
                f"{ERROR_COLOR}[error]{RESET} MIGRATIONS environment variable not found in .env"
            )
            sys.exit(1)
        if not database_url:
            print(
                f"{ERROR_COLOR}[error]{RESET} DATABASE_URL environment variable not found in .env"
            )
            sys.exit(1)

        cwd = os.path.dirname(os.path.abspath(__file__))
        # Build the migrate create command with specific parameters
        absolute_dir = os.path.join(cwd, migrations_source)
        # Build the migrate command
        cmd = ["migrate", "-path", absolute_dir, "-database", database_url]

        # Add the subcommand and any additional arguments
        if args.subcommand == "version":
            cmd.extend([args.subcommand] + getattr(args, "additional_args", []))
        else:
            cmd.extend([args.subcommand] + getattr(args, "additional_args", []))

        print(
            f"{SYSTEM_COLOR}[system]{RESET} {BOLD}Running migration: {' '.join(cmd)}{RESET}"
        )

        try:
            result = subprocess.run(cmd, cwd=migrations_source, check=True)
            print(f"{SYSTEM_COLOR}[system]{RESET} Migration completed successfully")
        except subprocess.CalledProcessError as e:
            print(
                f"{ERROR_COLOR}[error]{RESET} Migration failed with exit code {e.returncode}"
            )
            sys.exit(e.returncode)
        except FileNotFoundError:
            print(
                f"{ERROR_COLOR}[error]{RESET} migrate command not found. Make sure migrate is installed."
            )
            sys.exit(1)


def main():
    """Main command dispatcher."""
    parser = argparse.ArgumentParser(description="Development environment manager")
    subparsers = parser.add_subparsers(dest="command", help="Available commands")

    # TUI subcommands
    tui_parser = subparsers.add_parser("tui", help="Start TUI development environment")
    tui_group = tui_parser.add_mutually_exclusive_group()
    tui_group.add_argument("--go", action="store_true", help="Only start Go service")
    tui_group.add_argument(
        "--next", action="store_true", help="Only start Next.js service"
    )
    tui_group.add_argument(
        "--dev", action="store_true", help="Start both services (default)"
    )

    # Dev command (alias for TUI)
    dev_parser = subparsers.add_parser("dev", help="Start development environment")
    dev_group = dev_parser.add_mutually_exclusive_group()
    dev_group.add_argument("--go", action="store_true", help="Only start Go service")
    dev_group.add_argument(
        "--next", action="store_true", help="Only start Next.js service"
    )
    dev_group.add_argument(
        "--dev", action="store_true", help="Start both services (default)"
    )

    # Simple go command to start only Go service
    subparsers.add_parser("go", help="Start only Go service")

    # Simple next command to start only Next.js service
    subparsers.add_parser("next", help="Start only Next.js service")

    # Docker commands
    subparsers.add_parser("up", help="Start Docker dev environment")
    subparsers.add_parser("down", help="Stop Docker dev environment")
    subparsers.add_parser("prod-up", help="Start Docker prod environment")
    subparsers.add_parser("prod-down", help="Stop Docker prod environment")

    # Migration command
    migrate_parser = subparsers.add_parser("migrate", help="Run database migrations")
    migrate_subparsers = migrate_parser.add_subparsers(
        dest="subcommand", help="Migration subcommands"
    )

    # Add subcommands for migrate
    migrate_up = migrate_subparsers.add_parser("up", help="Apply migrations")
    migrate_up.add_argument(
        "additional_args", nargs="*", help="Additional arguments for up command"
    )

    migrate_down = migrate_subparsers.add_parser("down", help="Rollback migrations")
    migrate_down.add_argument(
        "additional_args", nargs="*", help="Additional arguments for down command"
    )

    migrate_create = migrate_subparsers.add_parser(
        "create", help="Create new migration"
    )
    migrate_create.add_argument("file_name", help="Name for the new migration file")

    migrate_drop = migrate_subparsers.add_parser("drop", help="Drop all migrations")
    migrate_drop.add_argument(
        "additional_args", nargs="*", help="Additional arguments for drop command"
    )

    migrate_force = migrate_subparsers.add_parser("force", help="Force version")
    migrate_force.add_argument(
        "additional_args", nargs="*", help="Additional arguments for force command"
    )

    migrate_version = migrate_subparsers.add_parser(
        "version", help="Get migration version"
    )
    migrate_version.add_argument(
        "additional_args", nargs="*", help="Additional arguments for version command"
    )

    args = parser.parse_args()

    if not args.command:
        parser.print_help()
        sys.exit(1)

    try:
        if args.command in ("dev", "tui"):
            # Determine which services to enable
            go_enabled = getattr(args, "go", False) or not (
                getattr(args, "next", False)
            )
            next_enabled = getattr(args, "next", False) or not (
                getattr(args, "go", False)
            )

            tui = TUI(go_enabled=go_enabled, next_enabled=next_enabled)
            tui.run()
        elif args.command == "go":
            # Start only the Go service without TUI
            parsed_env = load_dotenv(".env")
            go_service = ServiceManager(
                name="Go",
                cmd=["make", "dev"],
                cwd="apps/go-app",
                color=GO_COLOR,
                env=parsed_env,
            )
            print(f"{SYSTEM_COLOR}[system]{RESET} {BOLD}Starting Go service...{RESET}")
            if go_service.start():
                print(
                    f"{SYSTEM_COLOR}[system]{RESET} {BOLD}Go service started. Press Ctrl+C to stop.{RESET}"
                )
                try:
                    while True:
                        time.sleep(1)
                        if go_service.process and go_service.process.poll() is not None:
                            print(
                                f"{ERROR_COLOR}[system]{RESET} Go service stopped unexpectedly"
                            )
                            break
                except KeyboardInterrupt:
                    print(
                        f"\n{SYSTEM_COLOR}[system]{RESET} {BOLD}Stopping Go service...{RESET}"
                    )
                    go_service.stop()
                    print(
                        f"{SYSTEM_COLOR}[system]{RESET} {DIM}Go service stopped.{RESET}"
                    )
        elif args.command == "next":
            # Start only the Next.js service without TUI
            parsed_env = load_dotenv(".env")
            next_service = ServiceManager(
                name="Next.js",
                cmd=["bun", "run", "dev"],
                cwd="apps/next-app",
                color=NEXT_COLOR,
                env=parsed_env,
            )
            print(
                f"{SYSTEM_COLOR}[system]{RESET} {BOLD}Starting Next.js service...{RESET}"
            )
            if next_service.start():
                print(
                    f"{SYSTEM_COLOR}[system]{RESET} {BOLD}Next.js service started. Press Ctrl+C to stop.{RESET}"
                )
                try:
                    while True:
                        time.sleep(1)
                        if (
                            next_service.process
                            and next_service.process.poll() is not None
                        ):
                            print(
                                f"{ERROR_COLOR}[system]{RESET} Next.js service stopped unexpectedly"
                            )
                            break
                except KeyboardInterrupt:
                    print(
                        f"\n{SYSTEM_COLOR}[system]{RESET} {BOLD}Stopping Next.js service...{RESET}"
                    )
                    next_service.stop()
                    print(
                        f"{SYSTEM_COLOR}[system]{RESET} {DIM}Next.js service stopped.{RESET}"
                    )
        elif args.command == "up":
            docker_up_dev()
        elif args.command == "down":
            docker_down_dev()
        elif args.command == "prod-up":
            docker_up_prod()
        elif args.command == "prod-down":
            docker_down_prod()
        elif args.command == "migrate":
            if not args.subcommand:
                migrate_parser.print_help()
                sys.exit(1)
            run_migrate(args)
        else:
            parser.print_help()
            sys.exit(1)
    except KeyboardInterrupt:
        print("\nInterrupted by user")
        sys.exit(0)
    except Exception as e:
        print(f"Error: {e}", file=sys.stderr)
        sys.exit(1)


if __name__ == "__main__":
    main()
