#!/usr/bin/env python3
"""
Development environment manager for Go backend and Next.js frontend.
Provides a terminal UI for managing services with keyboard shortcuts.
No external dependencies - uses only Python standard library.
"""

import os
import sys
import re
import subprocess
import signal
import time
import threading
import select
import termios
import tty
import datetime
from typing import Optional, Dict, List

# ANSI Color Codes
RESET = "\033[0m"
BOLD = "\033[1m"
DIM = "\033[2m"
GO_COLOR = "\033[38;5;81m"
NEXT_COLOR = "\033[38;5;120m"
SYSTEM_COLOR = "\033[38;5;214m"
ERROR_COLOR = "\033[38;5;196m"
TIME_COLOR = "\033[38;5;244m"

# ============= Environment Parser =============
VAR_PATTERN = re.compile(r"(?<!\\)\$\{([^}]+)\}")  # matches ${VAR}, not \${VAR}


def expand_vars(value, env):
    """Expand ${VAR} using values from env."""

    def repl(match):
        var = match.group(1)
        return env.get(var, "")

    value = VAR_PATTERN.sub(repl, value)
    return value.replace(r"\${", "${")  # unescape \${VAR}


def parse_env_line(line):
    """Parse a single .env line into (key, value) or None."""
    line = line.strip()

    # Skip empty or full-line comments
    if not line or line.startswith("#"):
        return None

    # Remove 'export '
    if line.startswith("export "):
        line = line[len("export ") :].lstrip()

    # Split key=value
    if "=" not in line:
        return None

    key, value = line.split("=", 1)

    key = key.strip()
    value = value.strip()

    # Remove inline comments (only if outside quotes)
    if value and not (value.startswith('"') or value.startswith("'")):
        if " #" in value:
            value = value.split(" #", 1)[0].rstrip()
        elif "#" in value:
            value = value.split("#", 1)[0].rstrip()

    # Remove surrounding quotes
    if (value.startswith('"') and value.endswith('"')) or (
        value.startswith("'") and value.endswith("'")
    ):
        value = value[1:-1]

    return key, value


def load_dotenv(path=".env"):
    """
    Parse .env file with variable expansion.
    Returns dict of variables defined in the file.
    """
    env = {}
    base = os.environ.copy()

    if not os.path.exists(path):
        return env

    with open(path) as f:
        for raw in f:
            parsed = parse_env_line(raw)
            if not parsed:
                continue

            key, value = parsed

            # Merge known environment for expansion
            expanded = expand_vars(value, {**base, **env})
            env[key] = expanded

    return env


class ServiceManager:
    """Manages a single service process with lifecycle operations."""

    def __init__(
        self,
        name: str,
        cmd: List[str],
        cwd: str,
        color: str,
        env: Optional[Dict[str, str]] = None,
    ):
        self.name = name
        self.cmd = cmd
        self.cwd = cwd
        self.color = color
        self.env = env or {}
        self.pid: Optional[int] = None
        self.status = "stopped"
        self.process: Optional[subprocess.Popen] = None
        self.lock = threading.Lock()

    def start(self) -> bool:
        """Start the service process."""
        with self.lock:
            if self.process and self.process.poll() is None:
                return True

            self.status = "starting"
            self._print_status(f"Starting {self.name}...")

            # Merge system env with parsed .env vars
            env = os.environ.copy()
            env.update(self.env)

            try:
                # Create new process session for clean process group management
                self.process = subprocess.Popen(
                    self.cmd,
                    cwd=self.cwd,
                    env=env,
                    stdout=subprocess.PIPE,
                    stderr=subprocess.STDOUT,
                    text=True,
                    start_new_session=True,  # Key for clean process killing
                )
                self.pid = self.process.pid
                time.sleep(2)

                if self.process.poll() is None:
                    self.status = "running"
                    self._print_status(f"{self.name} started (PID: {self.pid})")

                    # Start log forwarding thread
                    thread = threading.Thread(target=self._log_forwarder, daemon=True)
                    thread.start()
                    return True
                else:
                    self.status = "stopped"
                    self._print_error(
                        f"{self.name} failed to start (exit code: {self.process.returncode})"
                    )
                    return False

            except FileNotFoundError as e:
                self.status = "stopped"
                self._print_error(f"Command not found: {self.cmd[0]} - {e}")
                return False
            except Exception as e:
                self.status = "stopped"
                self._print_error(f"Error starting {self.name}: {e}")
                return False

    def stop(self) -> None:
        """Stop service and its entire process tree."""
        with self.lock:
            if not self.process or self.process.poll() is not None:
                self.pid = None
                self.process = None
                self.status = "stopped"
                return

            self._print_status(f"Stopping {self.name} (PID: {self.pid})...")

            try:
                # Kill entire process group using negative PID
                if self.pid is None:
                    self._print_error(f"No PID found for {self.name}, cannot stop")
                    self.process = None
                    self.pid = None
                    self.status = "stopped"
                    return
                pgid = os.getpgid(self.pid)
                os.killpg(pgid, signal.SIGTERM)

                # Wait for graceful shutdown (5s max)
                for _ in range(50):
                    if self.process.poll() is not None:
                        break
                    time.sleep(0.1)
                else:
                    # Force kill if still alive
                    self._print_status(f"Force killing {self.name}...")
                    os.killpg(pgid, signal.SIGKILL)
                    time.sleep(0.5)

            except ProcessLookupError:
                pass
            except Exception as e:
                self._print_error(f"Error stopping {self.name}: {e}")

            self.process = None
            self.pid = None
            self.status = "stopped"

    def restart(self) -> bool:
        """Restart the service."""
        self._print_status(f"Restarting {self.name}...")
        self.status = "restarting"
        self.stop()
        time.sleep(0.5)
        return self.start()

    def _log_forwarder(self) -> None:
        """Forward and format logs from service stdout."""
        if not self.process or not self.process.stdout:
            return

        for line in iter(self.process.stdout.readline, ""):
            if line and not self.process.poll():
                timestamp = datetime.datetime.now().strftime("%H:%M:%S")
                gutter = "[go]  " if self.name == "Go" else "[next]"
                print(
                    f"{TIME_COLOR}{timestamp}{RESET} {self.color}{gutter}{RESET} {line.rstrip()}"
                )
                sys.stdout.flush()

    def _print_status(self, msg: str) -> None:
        """Print system status message."""
        print(f"{SYSTEM_COLOR}[system]{RESET} {BOLD}{msg}{RESET}")
        sys.stdout.flush()

    def _print_error(self, msg: str) -> None:
        """Print error message."""
        print(f"{ERROR_COLOR}[system]{RESET} {msg}")
        sys.stdout.flush()


class TUI:
    """Terminal User Interface for service management."""

    def __init__(self):
        # Parse .env file with variable expansion
        self.parsed_env = load_dotenv(".env")

        if self.parsed_env:
            print(
                f"{SYSTEM_COLOR}[system]{RESET} {DIM}Loaded {len(self.parsed_env)} variables from .env{RESET}"
            )
        else:
            print(
                f"{SYSTEM_COLOR}[system]{RESET} {DIM}No .env file found or empty{RESET}"
            )

        # Create services with parsed environment variables
        self.go_service = ServiceManager(
            name="Go",
            cmd=["make", "dev"],
            cwd="apps/go-app",
            color=GO_COLOR,
            env=self.parsed_env,  # All parsed env vars available to Go
        )

        self.next_service = ServiceManager(
            name="Next.js",
            cmd=["bun", "run", "dev"],
            cwd="apps/next-app",
            color=NEXT_COLOR,
            env=self.parsed_env,  # All parsed env vars available to Next.js
        )

        self.last_key = ""
        self.last_key_time = 0.0
        self.shutting_down = False

    def setup_terminal(self) -> None:
        """Configure terminal for immediate input."""
        self.fd = sys.stdin.fileno()
        self.old_settings = termios.tcgetattr(self.fd)
        tty.setcbreak(self.fd)
        sys.stdout.write("\033[?25l")  # Hide cursor
        sys.stdout.flush()

    def restore_terminal(self) -> None:
        """Restore terminal to original state."""
        sys.stdout.write("\033[?25h")  # Show cursor
        sys.stdout.flush()
        termios.tcsetattr(self.fd, termios.TCSADRAIN, self.old_settings)

    def print_header(self) -> None:
        """Display current service status header."""
        print(
            f"{BOLD}‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ{RESET}"
        )
        print(f"{BOLD}  Go Backend: {RESET}", end="")

        symbols = {
            "running": f"{GO_COLOR}‚óè{RESET} running  ",
            "starting": f"{SYSTEM_COLOR}‚óê{RESET} starting ",
            "stopped": f"{ERROR_COLOR}‚óã{RESET} stopped  ",
            "restarting": f"{SYSTEM_COLOR}‚Üª{RESET} restarting ",
        }
        print(symbols.get(self.go_service.status, "unknown "), end="")

        print(f"{BOLD}Next.js: {RESET}", end="")

        symbols = {
            "running": f"{NEXT_COLOR}‚óè{RESET} running",
            "starting": f"{SYSTEM_COLOR}‚óê{RESET} starting",
            "stopped": f"{ERROR_COLOR}‚óã{RESET} stopped",
            "restarting": f"{SYSTEM_COLOR}‚Üª{RESET} restarting",
        }
        print(symbols.get(self.next_service.status, "unknown"))

        print(
            f"{DIM}  Ctrl+C: quit  |  g‚Üír: restart Go  |  n‚Üír: restart Next  |  r: restart all{RESET}"
        )
        print(
            f"{BOLD}‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ{RESET}"
        )
        sys.stdout.flush()

    def handle_input(self) -> None:
        """Process keyboard commands."""
        if select.select([sys.stdin], [], [], 0.1)[0]:
            char = sys.stdin.read(1)
            current_time = time.time()

            # Reset chord on timeout
            if self.last_key and (current_time - self.last_key_time > 1.0):
                self.last_key = ""

            chord = self.last_key + char

            if chord == "gr":
                self.last_key = ""
                print("\033[2J\033[H")  # Clear screen
                self.print_header()
                self.go_service.restart()
            elif chord == "nr":
                self.last_key = ""
                print("\033[2J\033[H")
                self.print_header()
                self.next_service.restart()
            elif chord == "r" and not self.last_key:
                self.last_key = ""
                print("\033[2J\033[H")
                self.print_header()
                self.restart_all()
            elif char in ("g", "n"):
                self.last_key = char
                self.last_key_time = current_time
            else:
                self.last_key = ""

    def restart_all(self) -> None:
        """Restart both services."""
        print(f"{SYSTEM_COLOR}[system]{RESET} {BOLD}Restarting all services...{RESET}")
        self.go_service.restart()
        self.next_service.restart()
        print(f"{SYSTEM_COLOR}[system]{RESET} {DIM}All services restarted{RESET}")
        sys.stdout.flush()

    def cleanup(self) -> None:
        """Graceful shutdown of services and terminal restoration."""
        if self.shutting_down:
            return
        self.shutting_down = True

        print()
        print(f"{SYSTEM_COLOR}[system]{RESET} {BOLD}Shutting down...{RESET}")

        self.go_service.stop()
        self.next_service.stop()

        self.restore_terminal()
        time.sleep(0.1)  # Ensure terminal is fully restored

        print(
            f"{SYSTEM_COLOR}[system]{RESET} {DIM}All services stopped. Goodbye!{RESET}"
        )
        sys.stdout.flush()

    def run(self) -> None:
        """Main TUI execution loop."""

        def signal_handler(sig, frame):
            self.cleanup()
            sys.exit(0)

        signal.signal(signal.SIGINT, signal_handler)
        signal.signal(signal.SIGTERM, signal_handler)

        self.setup_terminal()

        print("\033[2J\033[H")  # Clear screen
        self.print_header()

        print(f"{SYSTEM_COLOR}[system]{RESET} {BOLD}Starting services...{RESET}")
        self.go_service.start()
        self.next_service.start()

        try:
            while not self.shutting_down:
                self.handle_input()

                # Health monitoring
                if self.go_service.status == "running" and self.go_service.process:
                    if self.go_service.process.poll() is not None:
                        self.go_service.status = "stopped"
                        print(
                            f"{ERROR_COLOR}[system]{RESET} Go backend stopped unexpectedly"
                        )

                if self.next_service.status == "running" and self.next_service.process:
                    if self.next_service.process.poll() is not None:
                        self.next_service.status = "stopped"
                        print(
                            f"{ERROR_COLOR}[system]{RESET} Next.js stopped unexpectedly"
                        )

                time.sleep(0.1)
        finally:
            # Ensure cleanup runs even on unexpected errors
            self.cleanup()


# Docker command functions
def docker_up_dev():
    """Start Docker development environment."""
    print("\nüê≥ Starting Docker dev environment...")
    subprocess.run(["docker", "compose", "-f", "docker-compose.dev.yml", "up", "-d"])


def docker_down_dev():
    """Stop Docker development environment."""
    print("\nüê≥ Stopping Docker dev environment...")
    subprocess.run(["docker", "compose", "-f", "docker-compose.dev.yml", "down"])


def docker_up_prod():
    """Start Docker production environment."""
    print("\nüöÄ Starting Docker prod environment...")
    subprocess.run(["docker", "compose", "-f", "docker-compose.prod.yml", "up", "-d"])


def docker_down_prod():
    """Stop Docker production environment."""
    print("\nüõë Stopping Docker prod environment...")
    subprocess.run(
        [
            "docker",
            "compose",
            "-f",
            "docker-compose.prod.yml",
            "down",
            "--remove-orphans",
        ]
    )


def print_usage():
    """Print usage instructions."""
    print("Usage: ./dev.py {dev|tui|up|down|prod-up|prod-down}")
    print()
    print("  dev/tui     - Start TUI development environment")
    print("  up          - Start Docker dev environment")
    print("  down        - Stop Docker dev environment")
    print("  prod-up     - Start Docker prod environment")
    print("  prod-down   - Stop Docker prod environment")
    sys.exit(1)


def main():
    """Main command dispatcher."""
    if len(sys.argv) < 2:
        print_usage()

    command = sys.argv[1]

    try:
        if command in ("dev", "tui"):
            tui = TUI()
            tui.run()
        elif command == "up":
            docker_up_dev()
        elif command == "down":
            docker_down_dev()
        elif command == "prod-up":
            docker_up_prod()
        elif command == "prod-down":
            docker_down_prod()
        else:
            print_usage()
    except KeyboardInterrupt:
        print("\nInterrupted by user")
        sys.exit(0)
    except Exception as e:
        print(f"Error: {e}", file=sys.stderr)
        sys.exit(1)


if __name__ == "__main__":
    main()
